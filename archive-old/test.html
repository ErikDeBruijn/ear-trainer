<!doctype html>
<html lang="en">
<!-- ROLI LUMI LED SysEx Test Page
        This page allows testing ROLI LUMI LED SysEx commands via Web MIDI API.

Findings (2025-08-16 v0.1):

Evolving Spec
- Header: F0 00 21 10 (ROLI)
- Observed on color changes: 77 43 (likely product/command family)
- Candidate commands:
  A) Global Key Color (palette byte): F0 00 21 10 77 43 00 20 00 00 PP F7
  B) Root Key Color  (palette byte): F0 00 21 10 77 43 00 21 00 00 PP F7
  C) Per-note RGB (guess):          F0 00 21 10 78 NN RR GG BB F7

- Color encoding hypotheses:
  • PP = palette index (examples seen: 6D, 6B)
  • RR/GG/BB = 7-bit per channel (0x00..0x7F)

Seed Captures
- F0 00 21 10 77 43 00 20 00 00 6D F7
- F0 00 21 10 77 43 00 20 00 00 6B F7
- Longer frames observed containing: … 03 46 60 32 36 … (unmapped)

Open Questions
- Is the last byte payload (palette) or a checksum?
- What addresses distinguish Global vs Root color?
- Confirm any per-note format and note numbering.
-->
<head>
    <meta charset="utf-8"/>
    <meta name="viewport" content="width=device-width, initial-scale=1"/>
    <title>ROLI LUMI – LED SysEx Test</title>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Inter, Roboto, Arial;
            margin: 24px;
        }

        fieldset {
            border: 1px solid #ccc;
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
        }

        legend {
            font-weight: 700;
        }
        button, select {
            padding: 8px 10px;
            border-radius: 8px;
            border: 1px solid #888;
            margin-right: 8px;
        }

        .row {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        #log {
            font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace;
            white-space: pre-wrap;
            background: #f7f7f7;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 0;
            min-height: 100px;
            max-height: 45vh;      /* keep it on screen */
            overflow-y: auto;      /* scroll instead of growing */
            position: relative;
        }
        #log .toolbar {
            position: sticky;
            top: 0;
            background: linear-gradient(#fafafa, #f2f2f2);
            border-bottom: 1px solid #ddd;
            padding: 6px 8px;
            z-index: 1;
        }
        #log-list > div { /* each log line */
            padding: 2px 8px;
        }

        .ok {
            color: #0a7a3c;
        }

        .bad {
            color: #b00020;
        }

        .muted {
            color: #666;
        }
        .warn { color: #8a3b00; }
        .okbadge { color: #0a7a3c; font-weight: 600; }
    </style>
    <script src="https://unpkg.com/webmidi@latest/dist/iife/webmidi.iife.js"></script>
</head>
<body>
<h1>ROLI LUMI – LED SysEx Test</h1>

<fieldset id="fs-enable">
    <legend>1) Enable MIDI (with SysEx)</legend>
    <div class="row">
        <button id="enable">Enable MIDI</button>
        <span id="status" class="muted">Not enabled</span>
    </div>
</fieldset>

<fieldset>
    <legend>2) Select ROLI Output</legend>
    <div class="row">
        <label>Output
            <select id="out"></select>
        </label>
        <button id="play">Play test tone (C4)</button>
        <span id="out-hint" class="muted"></span>
        <button id="bridge-spy" title="Input=Spy/IAC, Thru=ON, Output=LUMI">Bridge Spy → LUMI</button>
    </div>
    <div class="muted">Tip: Only ROLI/LUMI outputs are used for lighting; any output can play tones.</div>
</fieldset>

<fieldset>
    <legend>3) Send LED commands</legend>
    <div class="row">
        <button data-act="global-red">Global: Red</button>
        <button data-act="global-green">Global: Green</button>
        <button data-act="scale">Paint C major (C3–C5)</button>
        <button data-act="clear">Clear C3–C5</button>
    </div>
    <div class="row" style="margin-top:10px">
        <label>Raw SysEx (hex, spaces or commas):
            <input id="sysex-hex" style="width:520px" placeholder="f0 00 21 10 … f7"/>
        </label>
        <button id="send-sysex">Send SysEx</button>
    </div>
    <div class="muted">Tip: Capture LED SysEx by poking the official app and copying the output. Paste here to replay.</div>
</fieldset>

<fieldset>
    <legend>4) Captured presets (replay exact SysEx)</legend>
    <div class="row">
        <label style="min-width:160px">Preset 1 label
            <input id="p1-label" placeholder="Global Key Color (example)"/>
        </label>
        <label>Preset 1 SysEx
            <input id="p1-hex" style="width:480px" placeholder="f0 00 21 10 77 43 00 20 00 00 6d f7"/>
        </label>
        <button id="p1-send">Send</button>
        <button id="p1-save">Save</button>
    </div>
    <div class="row">
        <label style="min-width:160px">Preset 2 label
            <input id="p2-label" placeholder="Root Key Color (example)"/>
        </label>
        <label>Preset 2 SysEx
            <input id="p2-hex" style="width:480px" placeholder="f0 … f7"/>
        </label>
        <button id="p2-send">Send</button>
        <button id="p2-save">Save</button>
    </div>
    <div class="row">
        <label style="min-width:160px">Preset 3 label
            <input id="p3-label" placeholder="Your custom"/>
        </label>
        <label>Preset 3 SysEx
            <input id="p3-hex" style="width:480px" placeholder="f0 … f7"/>
        </label>
        <button id="p3-send">Send</button>
        <button id="p3-save">Save</button>
    </div>
    <div class="muted">These presets persist locally (browser localStorage). Paste captured SysEx from LUMI Dashboard
        here and replay to verify.
    </div>
</fieldset>

<fieldset>
    <legend>Log</legend>
    <div id="log">
        <div id="log-toolbar" class="toolbar row">
            <button id="clear-log">Clear log</button>
            <span class="muted">Newest first. Inline color swatches when a color payload is detected.</span>
        </div>
        <div id="log-list"></div>
    </div>
</fieldset>
<fieldset>
    <legend>Misc</legend>
    <div class="row">
        <button id="id-req">Send Universal Identity Request</button>
        <span class="muted">(Device should answer on its input port; check an external monitor if needed.)</span>
    </div>
</fieldset>

<fieldset>
    <legend>5) Capture incoming SysEx (no extra tools)</legend>
    <div class="row">
        <label>Input
            <select id="in"></select>
        </label>
        <button id="cap-start">Start capture</button>
        <button id="cap-stop" disabled>Stop</button>
        <label><input type="checkbox" id="cap-all" checked/> Capture from all inputs</label>
        <label><input type="checkbox" id="cap-thru"/> Thru to selected output</label>
        <label><input type="checkbox" id="filter-sysex" checked/> SysEx only</label>
        <label><input type="checkbox" id="show-log" checked/> Show log</label>
    </div>
    <div class="muted">
        To capture what another app sends to LUMI, route that app to a virtual input (macOS IAC). Select that input here and click <b>Start capture</b>. <b>Thru</b> is OFF by default to avoid loops; enable only if you want to forward captured bytes to the selected output.
    </div>
</fieldset>

<script>
    (() => {
        const NOTE_C4 = 60; // middle C
        const RANGE_LOW = 48; // C3
        const RANGE_HIGH_EXC = 72; // C5 (exclusive)

        const COLORS = {
            green: [0, 127, 0],
            red: [127, 0, 0],
            white: [127, 127, 127],
            darkred: [64, 0, 0],
            off: [0, 0, 0]
        };

        const statusEl = document.getElementById('status');
        const outSel = document.getElementById('out');
        const logEl = document.getElementById('log');
        const logListEl = document.getElementById('log-list');
        const inSel = document.getElementById('in');
        let out = null;
        let capturing = false;
        let stopCaptureFn = null;

        // Log behavior controls
        const MAX_LOG_LINES = 400;   // truncate really old messages
        const DEDUP_MAX = 1000;      // cap dedup memory
        const seenSet = new Set();
        const seenQueue = [];

        const showLogEl = () => document.getElementById('show-log');
        const filterSysexEl = () => document.getElementById('filter-sysex');
        function shouldLog() { return !!showLogEl()?.checked; }
        function sysexOnly() { return !!filterSysexEl()?.checked; }

        function log(msg, cls) {
            if (!shouldLog()) return;
            if (seenSet.has(msg)) return;
            seenSet.add(msg);
            seenQueue.push(msg);
            if (seenQueue.length > DEDUP_MAX) {
                const oldest = seenQueue.shift();
                seenSet.delete(oldest);
            }
            const line = document.createElement('div');
            if (cls) line.className = cls;
            line.textContent = msg;
            if (logListEl.firstChild) {
                logListEl.insertBefore(line, logListEl.firstChild);
            } else {
                logListEl.appendChild(line);
            }
            while (logListEl.childElementCount > MAX_LOG_LINES) {
                logListEl.removeChild(logListEl.lastChild);
            }
        }

        function refreshStatus() {
            const enabled = WebMidi.enabled;
            const sysex = WebMidi.sysexEnabled;
            statusEl.textContent = `MIDI: ${enabled ? 'OK' : 'OFF'} · SysEx: ${sysex ? 'OK' : 'DENIED'}`;
            statusEl.className = sysex ? 'ok' : 'bad';
            const fs = document.getElementById('fs-enable');
            if (fs) fs.style.display = (enabled && sysex) ? 'none' : '';
        }

        async function enableMidi() {
            try {
                if (WebMidi.enabled && !WebMidi.sysexEnabled) await WebMidi.disable();
                await WebMidi.enable({sysex: true});
                refreshStatus();
                // Populate outputs
                outSel.innerHTML = '';
                WebMidi.outputs.forEach(o => {
                    const opt = document.createElement('option');
                    opt.value = o.id;
                    opt.textContent = `${o.name}${/roli|lumi/i.test(o.name) ? ' (ROLI)' : ''}`;
                    outSel.appendChild(opt);
                });
                if (WebMidi.outputs[0]) {
                    outSel.value = WebMidi.outputs[0].id;
                    out = WebMidi.outputs[0];
                }
                refreshInputs();

                // Auto-arm capture with defaults (all inputs, thru OFF, sysex-only on)
                document.getElementById('cap-all').checked = true;
                document.getElementById('cap-thru').checked = false;
                document.getElementById('filter-sysex').checked = true;
                document.getElementById('show-log').checked = true;
                startCapture();

                if (WebMidi.inputs[0]) {
                    inSel.value = WebMidi.inputs[0].id;
                }
                log(`Enabled: enabled=${WebMidi.enabled} sysex=${WebMidi.sysexEnabled}`);
                logEl.scrollTop = 0; // show newest (we prepend)
            } catch (e) {
                log(`Enable failed: ${e.message}`, 'bad');
            }
        }

        function refreshInputs() {
            inSel.innerHTML = '';
            WebMidi.inputs.forEach(i => {
                const opt = document.createElement('option');
                opt.value = i.id;
                opt.textContent = i.name;
                inSel.appendChild(opt);
            });
        }

        function looksLikeLumiName(name) { return /\b(roli|lumi)\b/i.test(name || ''); }
        function looksLikeSpyName(name) { return /(iac|spy|dashboard|monitor)/i.test(name || ''); }
        function refreshOutHint() {
            const name = out?.name || '';
            const el = document.getElementById('out-hint');
            if (!el) return;
            if (!name) { el.textContent = 'No output selected'; el.className = 'warn'; return; }
            if (looksLikeLumiName(name)) { el.textContent = `→ Output: ${name}`; el.className = 'okbadge'; }
            else { el.textContent = `Output “${name}” does not look like a LUMI/ROLI port`; el.className = 'warn'; }
        }

        function formatBytes(data) {
            return Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' ');
        }

        function decode14(hi, lo) {
            // 7-bit safe pair → 14-bit value
            return ((hi & 0x7F) << 7) | (lo & 0x7F);
        }
        function clamp255(x) {
            return Math.max(0, Math.min(255, x|0));
        }
        function encode14(val14) {
            const v = Math.max(0, Math.min(16383, val14|0));
            return [(v >> 7) & 0x7F, v & 0x7F];
        }
        function rgb255To14Pairs(rgb) {
            const r14 = Math.round((rgb[0] / 255) * 16383);
            const g14 = Math.round((rgb[1] / 255) * 16383);
            const b14 = Math.round((rgb[2] / 255) * 16383);
            return [...encode14(r14), ...encode14(g14), ...encode14(b14)];
        }
        function sendGlobalColorRGB(rgb) {
            if (!out) return log('No output selected', 'bad');
            if (!/roli|lumi/i.test(out.name)) return log('Output is not ROLI/LUMI; skipping LED', 'bad');
            if (!WebMidi.sysexEnabled) return log('SysEx is DENIED; cannot send LED SysEx', 'bad');
            const pairs = rgb255To14Pairs(rgb);
            const msg = [0xF0,0x00,0x21,0x10,0x77,0x43,0x00,0x00,0x00,0x00,0x00,0x03,0x44, ...pairs, 0xF7];
            try {
                out.send(msg);
                const rgbApprox = tryExtractRGB(msg);
                logWithSwatch(`SysEx → ${msg.map(b=>b.toString(16).padStart(2,'0')).join(' ')}`, rgbApprox || rgb);
            } catch (e) {
                log(`SysEx failed: ${e.name}: ${e.message}`, 'bad');
            }
        }
        function rgbFromGlobalColorPayload(bytes) {
            // Look for ... 03 44 [Rhi Rlo Ghi Glo Bhi Blo] ... F7
            for (let i = 0; i < bytes.length - 8; i++) {
                if (bytes[i] === 0x03 && bytes[i+1] === 0x44) {
                    const r = decode14(bytes[i+2], bytes[i+3]);
                    const g = decode14(bytes[i+4], bytes[i+5]);
                    const b = decode14(bytes[i+6], bytes[i+7]);
                    // scale 0..16383 → 0..255
                    return [
                        clamp255(Math.round((r / 16383) * 255)),
                        clamp255(Math.round((g / 16383) * 255)),
                        clamp255(Math.round((b / 16383) * 255)),
                    ];
                }
            }
            return null;
        }
        function rgbFromPerNote78(bytes) {
            // F0 00 21 10 78 NN RR GG BB F7
            if (bytes.length >= 10 && bytes[0] === 0xF0 && bytes[4] === 0x78 && bytes[bytes.length-1] === 0xF7) {
                const rr = bytes[6] & 0x7F, gg = bytes[7] & 0x7F, bb = bytes[8] & 0x7F;
                return [
                    clamp255(Math.round(rr / 127 * 255)),
                    clamp255(Math.round(gg / 127 * 255)),
                    clamp255(Math.round(bb / 127 * 255)),
                ];
            }
            return null;
        }
        function tryExtractRGB(bytes) {
            return rgbFromGlobalColorPayload(bytes) || rgbFromPerNote78(bytes);
        }
        function logWithSwatch(msg, rgb, cls) {
            if (!shouldLog()) return;
            if (seenSet.has(msg)) return;
            seenSet.add(msg);
            seenQueue.push(msg);
            if (seenQueue.length > DEDUP_MAX) {
                const oldest = seenQueue.shift();
                seenSet.delete(oldest);
            }
            const line = document.createElement('div');
            if (cls) line.className = cls;
            const tt = document.createElement('span');
            tt.textContent = msg + ' ';
            line.appendChild(tt);
            if (rgb) {
                const [r,g,b] = rgb;
                const chip = document.createElement('span');
                chip.title = `rgb(${r},${g},${b})`;
                chip.style.display = 'inline-block';
                chip.style.width = '14px';
                chip.style.height = '14px';
                chip.style.border = '1px solid #999';
                chip.style.verticalAlign = 'middle';
                chip.style.background = `rgb(${r},${g},${b})`;
                chip.style.marginLeft = '6px';
                chip.style.borderRadius = '3px';
                line.appendChild(chip);
            }
            if (logListEl.firstChild) logListEl.insertBefore(line, logListEl.firstChild); else logListEl.appendChild(line);
            while (logListEl.childElementCount > MAX_LOG_LINES) logListEl.removeChild(logListEl.lastChild);
        }

        function onCapturedBytes(srcName, bytes) {
            if (!Array.isArray(bytes)) bytes = Array.from(bytes || []);
            if (sysexOnly() && bytes[0] !== 0xF0) return; // filter
            const hex = formatBytes(bytes);
            const rgb = tryExtractRGB(bytes);
            logWithSwatch(`[IN ${srcName}] ${hex}`, rgb);
            const thru = document.getElementById('cap-thru').checked;
            const outName = out?.name || '';
            if (thru && out && srcName) {
                // Avoid echo loops: only block if the src already matches our output device name
                const sameDevice = out.name && srcName && srcName.toLowerCase() === out.name.toLowerCase();
                if (!sameDevice) {
                    try { out.send(bytes); } catch (e) { log(`Thru failed: ${e.message}`, 'bad'); }
                }
            }
        }

        function setOutputById(id) {
            out = WebMidi.outputs.find(o => o.id === id) || null;
            log(`Selected output: ${out ? out.name : 'none'}`);
            refreshOutHint();
        }

        function sendTestTone(note = NOTE_C4) {
            if (!out) return log('No output selected', 'bad');
            try {
                out.playNote(note, {duration: 300, velocity: 0.9});
            } catch (e) {
                log(`Tone failed: ${e.message}`, 'bad');
            }
        }

        function sendLumiColor(note, rgb) {
            if (!out) return log('No output selected', 'bad');
            if (!/roli|lumi/i.test(out.name)) return log('Output is not ROLI/LUMI; skipping LED', 'bad');
            if (!WebMidi.sysexEnabled) return log('SysEx is DENIED; cannot send LED SysEx', 'bad');
            const sysex = [0xF0, 0x00, 0x21, 0x10, 0x78, (note & 0x7F), (rgb[0] & 0x7F), (rgb[1] & 0x7F), (rgb[2] & 0x7F), 0xF7];
            try {
                out.send(sysex);
                log(`SysEx → ${sysex.map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
            } catch (e) {
                log(`SysEx failed: ${e.name}: ${e.message}`, 'bad');
            }
        }

        function parseHexInput(str) {
            // Accept spaces, commas, newlines, 0x prefixes, mixed case, even concatenated bytes.
            // Strategy: split on non-hex to tokens; for each token, strip 0x and break into pairs.
            const tokens = str.replace(/[^0-9a-fA-Fx]/g, ' ').trim().split(/\s+/).filter(Boolean);
            const bytes = [];
            for (let tok of tokens) {
                tok = tok.replace(/^0x/i, '');
                if (!tok) continue;
                if (tok.length % 2 === 1) tok = '0' + tok; // pad odd nibble
                for (let i = 0; i < tok.length; i += 2) {
                    const byte = parseInt(tok.slice(i, i + 2), 16);
                    if (Number.isFinite(byte)) bytes.push(byte & 0xFF);
                }
            }
            return bytes;
        }

        async function sendRawSysex(bytes) {
            if (!bytes || bytes[0] !== 0xF0 || bytes[bytes.length - 1] !== 0xF7) {
                return log('SysEx must start with F0 and end with F7', 'bad');
            }
            try {
                if (!WebMidi.enabled) { await WebMidi.enable({sysex:true}); refreshStatus(); }
            } catch (e) { return log(`SysEx aborted: SysEx not enabled (${e.message})`, 'bad'); }
            if (!out) {
                const roli = WebMidi.outputs.find(o => /roli|lumi/i.test(o.name));
                if (roli) { out = roli; outSel.value = roli.id; log(`Auto-selected output: ${roli.name}`); }
            }
            if (!out) return log('No output selected (ROLI/LUMI not found).', 'bad');
            try {
                out.send(bytes);
                log(`Sent to: ${out.name}`);
                const hex = bytes.map(b => b.toString(16).padStart(2,'0')).join(' ');
                const rgb = tryExtractRGB(bytes);
                logWithSwatch(`SysEx → ${hex}`, rgb);
            } catch (e) {
                log(`SysEx failed: ${e.name}: ${e.message}`, 'bad');
            }
        }

        function setScaleColorsCmajor() {
            for (let m = RANGE_LOW; m < RANGE_HIGH_EXC; m++) {
                const pitchClass = m % 12; // C major = 0,2,4,5,7,9,11
                const inScale = [0, 2, 4, 5, 7, 9, 11].includes(pitchClass);
                sendLumiColor(m, inScale ? COLORS.white : COLORS.darkred);
            }
        }

        async function startCapture() {
            // Ensure WebMidi is enabled and a ROLI/LUMI output is selected
            if (!WebMidi.enabled) {
                try { await WebMidi.enable({sysex:true}); refreshStatus(); } catch (e) { log(`WebMidi enable failed: ${e.message}`, 'bad'); }
            }
            if (!out) {
                const roli = WebMidi.outputs.find(o => /roli|lumi/i.test(o.name));
                if (roli) { out = roli; outSel.value = roli.id; log(`Auto-selected output: ${roli.name}`); }
            }
            if (capturing) return;
            capturing = true;
            document.getElementById('cap-start').disabled = true;
            document.getElementById('cap-stop').disabled = false;
            try {
                const access = await navigator.requestMIDIAccess({ sysex: true });
                const all = document.getElementById('cap-all').checked;
                const selectedId = inSel.value;
                const inputs = [];
                access.inputs.forEach(i => inputs.push(i));
                const filtered = all ? inputs : inputs.filter(i => i.id === selectedId);
                const oldHandlers = [];
                filtered.forEach(inp => {
                    const prev = inp.onmidimessage;
                    oldHandlers.push(() => { inp.onmidimessage = prev || null; });
                    inp.onmidimessage = (ev) => {
                        const data = ev.data;
                        if (data && data.length) onCapturedBytes(inp.name, data);
                        if (typeof prev === 'function') { try { prev(ev); } catch {} }
                    };
                });
                stopCaptureFn = () => {
                    oldHandlers.forEach(fn => fn());
                    capturing = false;
                    document.getElementById('cap-start').disabled = false;
                    document.getElementById('cap-stop').disabled = true;
                };
                log('Capture started (native MIDI).');
            } catch (e) {
                log(`Failed to start capture: ${e.message}`, 'bad');
                capturing = false;
                document.getElementById('cap-start').disabled = false;
                document.getElementById('cap-stop').disabled = true;
            }
        }

        function stopCapture() {
            if (typeof stopCaptureFn === 'function') stopCaptureFn();
            stopCaptureFn = null;
        }

        document.getElementById('enable').addEventListener('click', enableMidi);
        outSel.addEventListener('change', (e) => setOutputById(e.target.value));
        document.getElementById('play').addEventListener('click', () => sendTestTone());

        document.getElementById('bridge-spy').addEventListener('click', () => {
            // Choose an input that looks like Spy/IAC
            const spyIn = WebMidi.inputs.find(i => looksLikeSpyName(i.name));
            if (spyIn) { inSel.value = spyIn.id; log(`Bridge: Input set to ${spyIn.name}`); }
            else { log('Bridge: No Spy/IAC input found', 'bad'); }
            // Choose a LUMI/ROLI output
            const lumiOut = WebMidi.outputs.find(o => looksLikeLumiName(o.name));
            if (lumiOut) { outSel.value = lumiOut.id; setOutputById(lumiOut.id); }
            else { log('Bridge: No LUMI/ROLI output found', 'bad'); }
            // Ensure Thru ON and start capture
            const thruCb = document.getElementById('cap-thru');
            thruCb.checked = true;
            startCapture();
            log('Bridge armed: Spy/IAC → (thru) → LUMI');
        });

        document.querySelector('[data-act="global-red"]').addEventListener('click', () => sendGlobalColorRGB([255,0,0]));
        document.querySelector('[data-act="global-green"]').addEventListener('click', () => sendGlobalColorRGB([0,255,0]));
        document.querySelector('[data-act="scale"]').addEventListener('click', setScaleColorsCmajor);
        document.querySelector('[data-act="clear"]').addEventListener('click', () => {
            for (let m = RANGE_LOW; m < RANGE_HIGH_EXC; m++) sendLumiColor(m, COLORS.off);
        });

        document.getElementById('send-sysex').addEventListener('click', () => {
            const val = document.getElementById('sysex-hex').value;
            const bytes = parseHexInput(val);
            sendRawSysex(bytes);
        });

        document.getElementById('id-req').addEventListener('click', () => {
            // Universal Identity Request: F0 7E 7F 06 01 F7
            sendRawSysex([0xF0, 0x7E, 0x7F, 0x06, 0x01, 0xF7]);
            log('Sent Universal Identity Request (device should respond on its MIDI IN → check a monitor bound to the device input).');
        });
        document.getElementById('clear-log').addEventListener('click', () => {
            logListEl.innerHTML = '';
            seenSet.clear();
            seenQueue.length = 0;
        });

        document.getElementById('cap-start').addEventListener('click', startCapture);
        document.getElementById('cap-stop').addEventListener('click', stopCapture);
        inSel.addEventListener('change', () => log(`Selected input: ${inSel.options[inSel.selectedIndex]?.text || '—'}`));

        // --- Presets (localStorage) ---
        const PKEY = 'lumi_sysex_presets_v1';

        function loadPresets() {
            try {
                return JSON.parse(localStorage.getItem(PKEY)) || {};
            } catch {
                return {};
            }
        }

        function savePresets(p) {
            localStorage.setItem(PKEY, JSON.stringify(p));
        }

        function initPresetsUI() {
            const p = loadPresets();
            const p1l = document.getElementById('p1-label');
            const p1h = document.getElementById('p1-hex');
            const p2l = document.getElementById('p2-label');
            const p2h = document.getElementById('p2-hex');
            const p3l = document.getElementById('p3-label');
            const p3h = document.getElementById('p3-hex');
            // defaults
            if (!p.p1) p.p1 = {label: 'Global Key Color (example)', hex: 'f0 00 21 10 77 43 00 20 00 00 6d f7'};
            p1l.value = p.p1?.label || '';
            p1h.value = p.p1?.hex || '';
            p2l.value = p.p2?.label || '';
            p2h.value = p.p2?.hex || '';
            p3l.value = p.p3?.label || '';
            p3h.value = p.p3?.hex || '';

            document.getElementById('p1-send').addEventListener('click', () => sendRawSysex(parseHexInput(p1h.value)));
            document.getElementById('p2-send').addEventListener('click', () => sendRawSysex(parseHexInput(p2h.value)));
            document.getElementById('p3-send').addEventListener('click', () => sendRawSysex(parseHexInput(p3h.value)));

            document.getElementById('p1-save').addEventListener('click', () => {
                p.p1 = {label: p1l.value, hex: p1h.value};
                savePresets(p);
                log('Saved Preset 1');
            });
            document.getElementById('p2-save').addEventListener('click', () => {
                p.p2 = {label: p2l.value, hex: p2h.value};
                savePresets(p);
                log('Saved Preset 2');
            });
            document.getElementById('p3-save').addEventListener('click', () => {
                p.p3 = {label: p3l.value, hex: p3h.value};
                savePresets(p);
                log('Saved Preset 3');
            });
        }

        // init presets UI now
        initPresetsUI();
        refreshOutHint();
    })();
</script>
</body>
</html>